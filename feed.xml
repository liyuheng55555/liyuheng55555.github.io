<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>LiYuHeng</title><subtitle>A minimal, responsive, and powerful Jekyll theme for presenting professional writing.</subtitle> <updated>2025-08-29T17:38:21+00:00</updated> <author> <name>Li Yu Heng</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="/"/> <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator> <rights> © 2025 Li Yu Heng </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>【CS336】BPE分词器训练</title><link href="/posts/BPE%E5%88%86%E8%AF%8D%E5%99%A8%E8%AE%AD%E7%BB%83/" rel="alternate" type="text/html" title="【CS336】BPE分词器训练" /><published>2025-08-25T00:00:00+00:00</published> <updated>2025-08-29T17:24:15+00:00</updated> <id>/posts/BPE%E5%88%86%E8%AF%8D%E5%99%A8%E8%AE%AD%E7%BB%83/</id> <content src="/posts/BPE%E5%88%86%E8%AF%8D%E5%99%A8%E8%AE%AD%E7%BB%83/" /> <author> <name>lyh</name> </author> <summary> 开个新坑～好几年没刷公开课了！ 实验总结 环境：macbook m3 air 24G 512G TinystoriesV2-GPT4-train数据集：预分词约46秒，merge约5秒 owt_train数据集：预分词约300秒（6并发），merge约1100秒 训练可以分为解耦的两大块，预分词、merge 预分词 使用讲义提供的正则表达式即可。 主要优化点就是多进程，这里我电脑只有8核所以就开个6进程，大家的CPU强的话进程数多多易善。 owt_train数据集的预分词需要做一下内存控制，在官方提供的pretokenization_example.py中做少许修改就可以实现。 由于预分词阶段没啥优化空间，我做了预分词结果缓存来跳过这个步骤，用python的pickle库。 预分词的结果我定义为list[tuple[TokenList, Num]]类... </summary> </entry> <entry><title>【15-445】CMU数据库系统 过程记录</title><link href="/posts/15-445-1-%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/" rel="alternate" type="text/html" title="【15-445】CMU数据库系统 过程记录" /><published>2022-10-01T00:00:00+00:00</published> <updated>2022-10-01T00:00:00+00:00</updated> <id>/posts/15-445-1-%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</id> <content src="/posts/15-445-1-%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/" /> <author> <name>lyh</name> </author> <summary> PROJECT #1 - BUFFER POOL LRU REPLACEMENT POLICY 容纳所有目前可被替换的frame id，并在需要替换的时候使用LRU算法，我用了一个list&amp;lt;frame_id_t&amp;gt;。 全局的mutex Pin的时候把frame id从链表中删除 Unpin的时候把frame id放到链表头部 Victim从链表尾部寻找 BUFFER POOL MANAGER INSTANCE 实现Buffer Pool实例。 这里函数比较多，有点不好理解，我们一点点分析，下面用BPMI代指BufferPoolManagerInstance。 首先，BPMI::disk_manager_是负责直接执行磁盘读写的；其负责写磁盘的成员函数void WritePage(page_id_t page_id, const... </summary> </entry> <entry><title>【15-445】CMU数据库系统 环境配置 win10+clion+docker</title><link href="/posts/15-445-0-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" rel="alternate" type="text/html" title="【15-445】CMU数据库系统 环境配置 win10+clion+docker" /><published>2022-08-28T00:00:00+00:00</published> <updated>2022-09-05T06:38:02+00:00</updated> <id>/posts/15-445-0-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id> <content src="/posts/15-445-0-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" /> <author> <name>lyh</name> </author> <summary> 在CS144的最后，好像说要肝6.824来着，但看了看好像不是目前最紧要的事情。 于是转头去做6.830，这个课实在是问题比较多，网上攻略也不多，最后环境没配出来… 那只好做15-445了，虽然之前义正词严地说拒绝C++… 在写CS144的过程中，对vscode的补全的响应速度和精准度不是很满意，于是这次体验一下Clion。 配置过程参考了https://zhuanlan.zhihu.com/p/458293882，他是主机ubuntu + Clion + docker。 在开始配之前，由于21年的gradescope是完整的5个评测，但有效期只到22年底，22年的评测现在又还没发布，两年的配置有一定差别，需要根据当前的时间做出选择。 如果是近期看到这篇文章（22年9-10月），那么推荐拉取21年的代码仓库并按本文配即可，然后在22年内做完实验；如果是更晚看到，推荐拉取最... </summary> </entry> <entry><title>【CS144】2 性能优化 6.1Gbit/s</title><link href="/posts/CS144-2-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="alternate" type="text/html" title="【CS144】2 性能优化 6.1Gbit/s" /><published>2022-08-19T00:00:00+00:00</published> <updated>2022-08-28T16:15:11+00:00</updated> <id>/posts/CS144-2-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id> <content src="/posts/CS144-2-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" /> <author> <name>lyh</name> </author> <summary> 主要参考了这位大佬https://zhuanlan.zhihu.com/p/414279516，优化得远没有他仔细，最后快一些想必是是占了硬件的便宜（ 我的电脑配置为： VmWare虚拟机 CPU：AMD 5600G，分配2×2个内核 内存：给虚拟机分配4G 开始尝试优化前，tcp_benchmark的两个结果均为1.8~1.9Gbit/s，TCP各部分所使用的数据结构与算法为： ByteStream：deque&amp;lt;char&amp;gt; Reassembler：类似list&amp;lt;string&amp;gt;，不合并 Sender：发出去的包使用list&amp;lt;TCPSegment&amp;gt;记录 尝试1：ByteStream累加生成string（负面效果） //更改前 string result = string(buffer.begin(), en... </summary> </entry> <entry><title>【CS144】1 过程记录</title><link href="/posts/CS144-1-%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/" rel="alternate" type="text/html" title="【CS144】1 过程记录" /><published>2022-07-25T00:00:00+00:00</published> <updated>2022-08-14T12:34:55+00:00</updated> <id>/posts/CS144-1-%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</id> <content src="/posts/CS144-1-%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/" /> <author> <name>lyh</name> </author> <summary> 因为课程不希望给出代码，所以就记录一下实现思路吧，每个lab的记录也不会太长 Lab0 warm up webget 主要是用connect write read eof这四个函数，可能唯一坑的地方在于Connection: close的时候需要\r\n两次。 byte_stream 功能是比较诡异，同一个进程在同一个对象上进行读写。 (做了lab1发现可能是为了解耦) 要求不是很全，有些细节需要看测试才能知道。 测试封装得很到位，很容易读，比如: test.execute(InputEnded{false}); // 调用InputEnded()函数，预期结果为false test.execute(BufferEmpty{false}); // 调用BufferEmpty()函数，预期结果为false 测试结果 Lab1 Reassembler ... </summary> </entry> </feed>
