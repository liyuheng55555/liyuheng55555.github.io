---
title: 【CS144】1 过程记录 
date: 2022-07-25 00:00:00 +/-TTTT
# categories: [TOP_CATEGORIE, SUB_CATEGORIE]
tags: [计算机网络, CS144]     # TAG names should always be lowercase
author: lyh
---

因为课程不希望给出代码, 所以就记录一下实现思路吧, 每个lab的记录也不会太长

# Lab0 warm up

## webget

主要是用`connect` `write` `read` `eof`这四个函数, 可能唯一坑的地方在于Connection: close的时候需要`\r\n`两次.

## byte_stream

功能是比较诡异, 同一个进程在同一个对象上进行读写. (做了lab1发现可能是为了解耦)

要求不是很全, 有些细节需要看测试才能知道.

测试封装得很到位, 很容易读, 比如:
```c
test.execute(InputEnded{false}); // 调用InputEnded()函数, 预期结果为false
test.execute(BufferEmpty{false}); // 调用BufferEmpty()函数, 预期结果为false
```

## 测试结果

<div align="center">
    <img src="/assets/img/2022-07-29%20%5Bcs144%5D/lab0%E6%B5%8B%E8%AF%95.PNG" width="50%">
</div>

# Lab1 Reassembler

实现对字节流的重组.

这个需求的corner case非常多, 而且需要自行设计数据结构, 思路不对的话写出来的代码又长又乱还没法保证正确性, ~~我推倒重来了两次~~, 不过修改设计的过程挺有意思的.

考虑过使用`list<deque>`这种结构, 并且在push过程中进行拼接, 后来感觉拼接的逻辑不太好写, `deque`的拼接性能也不太好, 就放弃了.

由于不再进行拼接, 最终使用的结构类似于`list<string>`, 从测试结果来看还是比较快的.

## 容易搞错的地方

有几个地方指导书没说清楚, 看了测试才懂:

- `index`是字节的序号, 不是分组的序号
- `eof = true`的意思是, 本次的`data`后面跟着一个`eof`, 在序号上位于这个`eof`前面的字节依然可以接收, 后面的字节就不接收了
- `_capacity`是`ByteStream`和`Reassembler`的总容量, 也就是说每次接收字符串之后它俩存的字符总数不超过`_capacity`

## 实现简述

在`StreamReassembler`中, 我添加了这些`private`元素:
- 定义结构体`Segment`:
  - 字符串`data`
  - `data`首末字节的序号`start_idx`与`end_idx`
- `list<Segment> seg_list`, 储存没组装好的数据
- `volume`, 目前有多少字节没组装好
- `global_index`, 下个希望收到的字节编号, 初始值`0`
- `eof_index`, 此编号后的字节不再接收, 初始值`UINT64_MAX`

我的`push_substring()`逻辑是这样:

1. 如果`eof = true`, 考虑修改`eof_index`
2. 去除`data`位于`global_index`前面的部分
3. 去除`data`位于`eof_index`后面的部分
4. 如果`seg_list`为空, 直接插入
5. 可能有些部分插在`seg_list`最前面或最后面, 单独处理
6. 向`seg_list`中间插入
7. 从`seg_list`头部开始扫描, 将组装好的部分移动到`_output`
8. 从`seg_list`尾部开始扫描, 去除超出`_capacity`的部分
9.  考虑是否调用`_output.end_input()`


## 测试结果

<div align="center">
    <img src="/assets/img/2022-07-29%20%5Bcs144%5D/lab1%E6%B5%8B%E8%AF%95.PNG" width="50%">
</div>

# Lab2 TCP receiver

实现TCP接收功能.

不要直接照着正版TCP的状态转换图去写, 得照着教材给的`LISTEN`, `SYN_RECV`, `FIN_RECV`三状态转换图来写.

感觉教材比较惜字如金...说`unwrapper(n,isn,checkpoint)`的功能是获取和`checkpoint`相比最为**closest**的序号, 我就理解成了`≥checkpoint`的最小值, 但它其实可以多说一句**no matter less or more**.

还有测试数据里有`syn+fin`这种组合, 这个怎么看都是不合法的包, 应该直接抛弃啊, 但测试认为正确反应是接收这个包并紧接着终止接收. 前不久[知乎上还有人问了这个事](https://www.zhihu.com/question/513379485), 人家linux都是直接抛弃的.

`syn`和`fin`本身也占字节流序号, 这个事很容易忽略, 导致`ackno()`错误. 这样设计的缘由是<https://www.zhihu.com/question/24792770>.


# Lab3 TCP sender

实现TCP发送功能, 支持超时重传和累计确认.

一共实现4个函数, 分别是:

- `bytes_in_flight()`: 目前发送过的所有数据中有多少个字节还没有被确认.
- `fill_window()`: 填满发送窗口. 当然, 得考虑到自己有没有那么多数据可发. `syn`和`fin`本身也占字节流序号这个事可能会带来一些麻烦.
- `ack_received(ackno,window_size)`: 可以认为是TCP接收到了一个带确认的包, 于是把这个包携带的`ackno`和`window_size`告知sender. 
- `tick(ms_since_last_tick)`: TCP连接会定期调用这个方法, 以便sender可以知道当前时间, 并决定是否重传.
- `consecutive_retransmissions()`: 当前重传次数.
- `send_empty_segment()`: 发送一个不带数据段的包.

写代码的时间大约50%都在面向测试编程, 细节太多了, 还好给看具体测试内容, 不然估计改一周也过不了.

教材给了6种状态, 但我只用了其中3种(CLOSED, SYN_SENT, FIN_SENT), 也不知道到Lab4会不会出问题...


